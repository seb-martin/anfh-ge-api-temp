<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="par-model">

  <template>

    <!-- Accès aux données -->
    <par-regions-dao id="regionsDao"></par-regions-dao>
    <par-axes-dao id="axesDao"></par-axes-dao>
    <par-actions-dao id="actionsDao"></par-actions-dao>

  </template>

  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'par-model',

      properties: {

        /**
         * Indique si un élément du modèle est en cours de synchro
         */
        synchronizing: {
          type: Boolean,
          notify: true,
          readonly: true,
          value: true
        },

        regions: {
          type: Array,
          notify: true
        },
        selectedRegion: {
          type: Object,
          notify: true
        },
        exercices: {
          type: Array,
          notify: true,
          // readOnly: true,
          value: function() {
            var currentYear = (new Date()).getFullYear();
            return [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];
          }
        },
        selectedExercice: {
          type: Number,
          notify: true
        },
        axes: {
          type: Array,
          notify: true,
          // readOnly: true
        },
        selectedAxe: {
          type: Object,
          notify: true
        },
        actions: {
          type: Array,
          notify: true,
          // readOnly: true
        },
        selectedAction: {
          type: Object,
          notify: true
        }
      },

      observers: [
        'refreshAxes(selectedRegion, selectedExercice)',
        'refreshActions(selectedRegion, selectedExercice)'
      ],

      ready: function() {
        this.regionsDao = this.$.regionsDao;
        this.axesDao = this.$.axesDao;
        this.actionsDao = this.$.actionsDao;
        this.refreshRegions();
      },

      refreshRegions: function() {
        var self = this;
        this.synchronizing = true;

        return this.regionsDao.lister().then(function(regions) {
          self.regions = regions;
          self.synchronizing = false;
        }).catch(function(error) {
          self.synchronizing = false;
          self.fire('error', error);
        });
      },

      selectRegion: function(code) {
        var self = this;
        if (code) {

          var differe = function(code) {
            if (self.synchronizing) {
              self.async(differe, 50);
            } else {
              if (!self.selectedRegion || self.selectedRegion.code !== code) {
                self.regions.forEach(function(r) {
                  if (r.code === code) {
                    self.selectedRegion = r;
                  }
                });
              }
            }
          };

          differe(code);

        } else {
          this.selectedRegion = null;
        }
      },

      refreshAxes: function(selectedRegion, selectedExercice) {

        var self = this;
        if (selectedRegion && selectedExercice) {
          this.synchronizing = true;
          return this.axesDao.lister(selectedRegion.code, selectedExercice)
          .then(function(axes) {
            self.axes = axes;
            self.synchronizing = false;
            return axes;
          }).catch(function(error) {
            self.synchronizing = false;
            self.fire('error', error);
          });
        } else {
          this.axes = [];
        }
      },
      
      newAxe: function() {
      },

      createAxe: function() {
        var self = this;
        this.synchronizing = true;

        // Pour prévenir les doublons de requête de création (non indempotente),
        // on conserve la promesse de la requête de création en cours.
        if (this.createRequest) {
          return this.createRequest;
        } else {
          this.createRequest = this.axesDao.creer(this.selectedAxe)
          .then(function() {
            return self.refreshAxes(self.selectedRegion, self.selectedExercice)
            .then(function() {
              self.createRequest = null;
            });
          }).catch(function(error) {
            self.synchronizing = false;
            self.createRequest = null;
            self.fire('error', error);
          });

          return this.createRequest;
        }
      },

      editAxe: function(/* axe */) {
      },

      updateAxe: function() {
        var self = this;
        this.synchronizing = true;
        return this.axesDao.modifier(this.selectedAxe)
        .then(function() {
          return self.refreshAxes(self.selectedRegion, self.selectedExercice);
        }).catch(function(error) {
          self.synchronizing = false;
          self.fire('error', error);
        });
      },

      deleteAxe: function() {
        var self = this;
        this.synchronizing = true;
        return this.axesDao.supprimer(this.selectedAxe).then(function() {
          return self.refreshAxes(self.selectedRegion, self.selectedExercice);
        }).catch(function(error) {
          self.synchronizing = false;
          self.fire('error', error);
        });

      },

      refreshActions: function(selectedRegion, selectedExercice) {
        var self = this;
        if (selectedRegion && selectedExercice) {
          this.synchronizing = true;
          return this.actionsDao.lister(selectedRegion.code, selectedExercice)
          .then(function(actions) {
            self.actions = actions;
            self.synchronizing = false;
            return actions;
          }).catch(function(error) {
            self.synchronizing = false;
            self.fire('error', error);
          });
        } else {
          this.actions = [];
        }
      },
      
      newAction: function() {
      },

      createAction: function() {
        var self = this;
        this.synchronizing = true;

        // Pour prévenir les doublons de requête de création (non indempotente),
        // on conserve la promesse de la requête de création en cours.
        if (this.createRequest) {
          return this.createRequest;
        } else {
          this.createRequest = this.actionsDao.creer(this.selectedAction)
          .then(function() {
            return self.refreshActions(self.selectedRegion, self.selectedExercice)
            .then(function() {
              self.createRequest = null;
            });
          }).catch(function(error) {
            self.synchronizing = false;
            self.createRequest = null;
            self.fire('error', error);
          });

          return this.createRequest;
        }
      },

      editAction: function(/* axe */) {
      },

      updateAction: function() {
        var self = this;
        this.synchronizing = true;
        return this.actionsDao.modifier(this.selectedAction).then(function() {
          return self.refreshActions(self.selectedRegion, self.selectedExercice);
        }).catch(function(error) {
          self.synchronizing = false;
          self.fire('error', error);
        });
      },

      deleteAction: function() {
        var self = this;
        this.synchronizing = true;
        return this.actionsDao.supprimer(this.selectedAction).then(function() {
          return self.refreshActions(self.selectedRegion, self.selectedExercice);
        }).catch(function(error) {
          self.synchronizing = false;
          self.fire('error', error);
        });

      }

    });
  })();
  </script>
</dom-module>
